import { readFile, writeFile } from 'fs/promises'
import { basename, relative } from 'path'
import { Document, parse, stringify } from 'yaml'

import { migrateMessage } from './migrate-message.js'

/**
 * @param {string} propPath
 * @returns {string}
 */
export const configPath = (propPath) =>
  propPath.replace(/properties$/, 'migration.yaml')

/**
 * @param {string} propPath - Path to `.properties` file
 * @returns {Promise<{
 *   ftl: { root: string, path: string },
 *   migrate: Record<string, import('./migrate-message.js').MessageMigration>
 * } | null>}
 */
export async function readMigrationConfig(root, propPath) {
  const cfgPath = configPath(propPath)
  let src
  try {
    src = await readFile(cfgPath, 'utf8')
  } catch (error) {
    if (error.code === 'ENOENT') return null
    throw error
  }
  const relPath = relative(root, cfgPath)
  console.warn(`Found migration config at ${relPath}`)

  const { ftl, migrate } = parse(src)
  if (
    !ftl ||
    !ftl.root ||
    !ftl.path ||
    typeof ftl.root !== 'string' ||
    typeof ftl.path !== 'string'
  ) {
    throw new Error(
      `Invalid ftl value in ${relPath}, expected { root: string, path: string }`
    )
  }
  if (!migrate || typeof migrate !== 'object' || Array.isArray(migrate)) {
    throw new Error(
      `Invalid migrate value in ${relPath}, expected Record<string, MessageMigration>`
    )
  }

  for (const [key, value] of Object.entries(migrate)) {
    if (!value) delete migrate[key]
    else {
      value.attr ??= null
      value.varNames ??= []
      if (
        typeof value !== 'object' ||
        Array.isArray(value) ||
        !value.key ||
        typeof value.key !== 'string' ||
        (value.attr && typeof value.attr !== 'string') ||
        !Array.isArray(value.varNames)
      ) {
        throw new Error(
          `Invalid migrate.${key} value in ${relPath}, expected { key: string, attr?: string, varNames?: string[] } or null`
        )
      }
    }
  }

  return { ftl, migrate }
}

/**
 * @param {string} root
 * @param {import('./parse-message-files.js').PropData} propData
 * @returns {string} Path to migration config file
 */
export async function writeMigrationConfig(root, propData) {
  const { ast, ftlPath, ftlRoot, migrate, msgKeys, path } = propData
  const doc = new Document({
    ftl: { root: ftlRoot, path: ftlPath },
    migrate: {}
  })
  doc.commentBefore = `\
 This is the properties-to-ftl migration config for ${basename(path)}.
 This file was generated by the script, but should be manually modified.
 More information: https://github.com/mozilla/properties-to-ftl/
 
 Edit this file to set the Fluent message keys and variable names, and
 then re-run the same command as previously to complete the migration.
 
 The \`migrate\` object has keys matching each of the .properties messages.
 Keys with a null/empty value will not be migrated; all #comments are
 ignored. For each message to be migrated, \`key\` is required. If \`attr\`
 is set, the message will be set as that attribute of the parent message.
 
 This file SHOULD NOT BE ADDED TO THE SOURCE REPOSITORY.
 It may be safely removed after the migration has been completed.`

  const fixVars = []
  doc.get('migrate').items = msgKeys.map((propKey) => {
    let pair
    if (migrate.hasOwnProperty(propKey)) {
      const { key, attr, varNames } = migrate[propKey]
      const value = { key }
      if (attr) value.attr = attr
      if (varNames.length > 0) value.varNames = varNames
      pair = doc.createPair(propKey, value)
      for (let i = 0; i < varNames.length; ++i) {
        if (/^var\d+$/.test(varNames[i])) {
          const node = pair.value.getIn(['varNames', i], true)
          if (node) node.comment = ' FIXME'
          fixVars.push(key)
        }
      }
    } else {
      pair = doc.createPair(propKey, null)
      const { key, attr, varNames } = migrateMessage(propData, propKey, [])
      const comment = { key }
      if (attr) comment.attr = attr
      if (varNames.length > 0) comment.varNames = varNames
      pair.value.commentBefore = stringify(comment)
        .replace(/^/gm, ' ')
        .trimEnd()
    }
    pair.key.spaceBefore = true
    const msg = ast.find((node) => node.type === 'PAIR' && node.key === propKey)
    if (msg) pair.key.comment = ' ' + msg.value.replace(/\r?\n/g, '\\n')
    return pair
  })

  const cfgPath = configPath(path)
  await writeFile(cfgPath, doc.toString({ nullStr: '' }))

  console.warn(`\
Migration configuration for ${basename(path)} written to:

${relative(root, cfgPath)}

Edit this file to set the Fluent message keys and variable names, and
then re-run the same command as previously to complete the migration.
After this migration is complete, this config file may be removed;
it should NOT be added to the source repo.`)

  if (fixVars.length === 1) {
    console.warn(`
!!! Variable name generation was not successful for "${fixVars[0]}".
!!! Review and modify this manually; the config file includes a FIXME comment.`)
  } else if (fixVars.length > 0) {
    console.warn(`
!!! Variable name generation was not successful for ${fixVars.length} messages.
!!! You should review these manually; the config file includes FIXME comments.`)
  }

  return cfgPath
}
