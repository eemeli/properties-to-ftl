import { readFile, writeFile } from 'fs/promises'
import { basename, relative } from 'path'
import { Document, parse, stringify } from 'yaml'

import { migrateMessage } from './migrate-message.js'
import { fail } from './util-fail.js'

/**
 * @param {string} propPath
 * @returns {string}
 */
export const configPath = (propPath) =>
  propPath.replace(/properties$/, 'migration.yaml')

/**
 * @param {string} root
 * @param {string} propPath - Path to `.properties` file
 * @returns {Promise<{
 *   ftl: { root: string, path: string },
 *   meta: { bug: string, title: string },
 *   migrate: Record<string, import('./migrate-message.js').MessageMigration>
 * } | null>}
 */
export async function readMigrationConfig(root, propPath) {
  const cfgPath = configPath(propPath)
  let src
  try {
    src = await readFile(cfgPath, 'utf8')
  } catch (error) {
    if (error.code === 'ENOENT') return null
    fail(error)
  }
  const relPath = relative(root, cfgPath)
  console.warn(`Found migration config at ${relPath}`)

  /**
   * @type {{
   *   ftl?: { root: string, path: string },
   *   meta?: { bug: string, title: string },
   *   migrate: Record<string, import('./migrate-message.js').MessageMigration>
   * }}
   */
  const { ftl, meta, migrate } = parse(src, { schema: 'failsafe' })
  if (
    !meta ||
    !meta.bug ||
    !meta.title ||
    typeof meta.bug !== 'string' ||
    typeof meta.title !== 'string'
  ) {
    fail(`
Invalid meta value in
  ${relPath}
Expected { bug: string, title: string }.`)
  }
  if (
    !ftl ||
    !ftl.root ||
    !ftl.path ||
    typeof ftl.root !== 'string' ||
    typeof ftl.path !== 'string'
  ) {
    fail(`
Invalid ftl value in
  ${relPath}
Expected { root: string, path: string }.`)
  }
  if (!migrate || typeof migrate !== 'object' || Array.isArray(migrate)) {
    fail(`
Invalid migrate value in
  ${relPath}
Expected Record<string, MessageMigration>.`)
  }

  for (const [key, value] of Object.entries(migrate)) {
    if (!value) delete migrate[key]
    else {
      value.attr ??= null
      value.varNames ??= []
      if (
        typeof value !== 'object' ||
        Array.isArray(value) ||
        !value.key ||
        typeof value.key !== 'string' ||
        (value.attr && typeof value.attr !== 'string') ||
        !Array.isArray(value.varNames)
      ) {
        fail(`
Invalid migrate.${key} value in
  ${relPath}
Expected null or {
  key: string,
  attr?: string,
  plural?: string | false,
  varNames?: string[]
}.`)
      }
      if ('plural' in value) {
        if (
          value.plural
            ? typeof value.plural !== 'string'
            : value.plural !== false
        ) {
          fail(`
Invalid migrate.${key}.plural value in
  ${relPath}
This value must either be explicitly false or a string identifying
the variable used to determine the plural category.`)
        }
      } else value.plural = null
    }
  }

  return { ftl, meta, migrate }
}

/**
 * @param {import('./parse-message-files.js').PropData} propData
 * @param {import('./transform-js.js').TransformOptions} options
 * @returns {Promise<string>} Path to migration config file
 */
export async function writeMigrationConfig(propData, { all, bug, root }) {
  const { ast, ftlPath, ftlRoot, migrate, msgKeys, path } = propData
  const doc = new Document({
    meta: {
      bug: bug || 'xxxxxx',
      title: `Convert ${basename(propData.path)} to Fluent`
    },
    ftl: { root: ftlRoot, path: ftlPath },
    migrate: {}
  })
  doc.commentBefore = `\
 This is the properties-to-ftl migration config for ${basename(path)}.
 This file was generated by the script, but should be manually modified.
 More information: https://github.com/mozilla/properties-to-ftl/
 
 Edit this file to set the Fluent message keys and variable names, and
 then re-run the same command as previously to complete the migration.
 
 The \`migrate\` object has keys matching each of the .properties messages.
 Keys with a null/empty value will not be migrated; all #comments are
 ignored. For each message to be migrated, \`key\` is required. If \`attr\`
 is set, the message will be set as that attribute of the parent message.
 
 This file SHOULD NOT BE ADDED TO THE SOURCE REPOSITORY.
 It may be safely removed after the migration has been completed.`

  if (!bug) doc.getIn(['meta', 'bug'], true).comment = ' FIXME'
  for (const pair of doc.contents.items) pair.key.spaceBefore = true

  /** @type {string[]} */
  const fixVars = []
  doc.get('migrate').items = msgKeys.map((propKey) => {
    /** @type {import('yaml').Pair} */
    let pair
    /** @type {import('./migrate-message.js').MessageMigration | null} */
    let mm = null
    if (migrate.hasOwnProperty(propKey)) {
      mm = migrate[propKey]
      pair = doc.createPair(propKey, prettyMessageMigration(mm))
    } else if (all) {
      mm = migrateMessage(propData, propKey, null)
      pair = doc.createPair(propKey, prettyMessageMigration(mm))
    } else {
      pair = doc.createPair(propKey, null)
      const mc = prettyMessageMigration(migrateMessage(propData, propKey, null))
      pair.value.commentBefore = stringify(mc).replace(/^/gm, ' ').trimEnd()
    }
    if (mm?.plural) {
      const node = pair.value.get('plural', true)
      if (node && !node.value) node.comment = ' FIXME'
    }
    if (mm?.varNames) {
      for (let i = 0; i < mm.varNames.length; ++i) {
        if (/^var\d+$/.test(mm.varNames[i])) {
          const node = pair.value.getIn(['varNames', i], true)
          if (node) node.comment = ' FIXME'
          fixVars.push(mm.key)
        }
      }
    }
    pair.key.spaceBefore = true
    const msg = ast.find((node) => node.type === 'PAIR' && node.key === propKey)
    if (msg) pair.key.comment = ' ' + msg.value.replace(/\r?\n/g, '\\n')
    return pair
  })

  const cfgPath = configPath(path)
  await writeFile(cfgPath, doc.toString({ nullStr: '' }))

  console.warn(`\
Migration configuration for ${basename(path)} written to:

${relative(root, cfgPath)}

Edit this file to set the Fluent message keys and variable names, and
then re-run the same command as previously to complete the migration.
After this migration is complete, this config file may be removed;
it should NOT be added to the source repo.
`)

  if (fixVars.length === 1) {
    console.warn(`
!!! Variable name generation was not successful for "${fixVars[0]}".
!!! Review and modify this manually; the config file includes a FIXME comment.`)
  } else if (fixVars.length > 0) {
    console.warn(`
!!! Variable name generation was not successful for ${fixVars.length} messages.
!!! You should review these manually; the config file includes FIXME comments.`)
  }

  return cfgPath
}

/**
 * @param {import('./migrate-message').MessageMigration} migration
 */
function prettyMessageMigration({ key, attr, plural, varNames }) {
  /** @type {Partial<import('./migrate-message.js').MessageMigration>} */
  const value = { key }
  if (attr) value.attr = attr
  if (plural) value.plural = null
  if (varNames.length > 0) value.varNames = varNames
  return value
}
